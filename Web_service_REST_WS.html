<!DOCTYPE html>
<html>
<title>Web_service_REST_WS</title>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://code.jquery.com/mobile/1.4.5/jquery.mobile-1.4.5.min.css">
<script src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
<script src="https://code.jquery.com/mobile/1.4.5/jquery.mobile-1.4.5.min.js"></script>
<style type="text/css">
	.redC{color:red}
	.aa{color:blue}
	</style>
</head>
<body>
<div data-role="page">
  <div data-role="header" data-position="fixed">
      <br/>
      <b style="color: red"><a href="coreJava.html">Core Java</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="Database.html">Database</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="Hibernate.html">Hibernate</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="Spring.html">Spring</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="Struts.html">Struts</a></b>
      <br/>
  </div>
  <div data-role="main" class="ui-content">
	<b class="redC">NOTE:-</b><br/>
	REST is stateless, server does not stores any session on server side.<br/>
	The client's application state should never be stored on the server, but passed around from the client to every place that needs it.<br/>
	That is where the ST in REST comes from, State Transfer. You transfer the state around instead of having the server store it.<br/>
	This is the only way to scale to millions of concurrent users. If for no other reason than because millions of sessions is millions of sessions.<br/>
	<b class="redC">Example of transfering the state is use of Token like JWT</b><br/>
	<br/>
  <b class="redC">Question:-What is use of @ResponseStatus</b><br/>
  <font class="redC">Answer:-</font>
  We use @ResponseStatus to mark a method or an exception class with a status code and that should be returned
  On invoking the marked handler method or when a specified exception is thrown, the HTTP status will be set to the one defined using @ResponseStatus annotation.
  <font class="aa">If we mark our Controller class with this annotation. For such a case, the response code configuration will be applied to all the request handler methods.</font>
  <br/><br/>
  
  <b class="redC">Question:-How can we do Exception handling in Spring REST</b><br/>
  <font class="redC">Answer:-</font>
  @ControllerAdvice and @ExceptionHandler annotation are used to handle Exception in Spring REST 
  <br/><br/>
  
  <b class="redC">Note:-</b><br/>
  Note that <font class="aa">ResponseEntityExceptionHandler</font> is a convenient base class for @ControllerAdvice classes that 
  wish to provide centralized exception handling across all @RequestMapping methods through @ExceptionHandler methods.
  <font class="aa">Example in project:Spring-REST-JSON</font>
  <br/><br/>
  
  <b class="redC">Question:-What is @RestController</b><br/>
  <font class="redC">Answer:-</font>
  First of all, we are using Spring 4’s new @RestController annotation. This annotation eliminates the need of
  annotating each method with @ResponseBody. Under the hood, @RestController is itself annotated with @ResponseBody,
  and can be considered as combination of @Controller and @ResponseBody.
  <br/><br/>
  
  <b class="redC">Question:-What is @RequestBody</b><br/>
  <font class="redC">Answer:-</font>
  If a method parameter is annotated with @RequestBody, Spring will bind the incoming HTTP request
  body(for the URL mentioned in @RequestMapping for that method) to that parameter. While doing that, Spring will [behind the
  scenes] use HTTP Message converters to convert the HTTP request body into domain object [deserialize request body to
  domain object], based on ACCEPT or Content-Type header present in request.
  <br/><br/>
  
  <b class="redC">Question:-What is @ResponseBody</b><br/>
  <font class="redC">Answer:-</font>
  If a method is annotated with @ResponseBody, Spring will bind the return value to outgoing HTTP
  response body. While doing that, Spring will [behind the scenes] use HTTP Message converters to convert the return value to
  HTTP response body [serialize the object to response body], based on Content-Type present in request HTTP header. As
  already mentioned, in Spring 4, you may stop using this annotation.
  <br/><br/>
  
  <b class="redC">Question:-What is ResponseEntity</b><br/>
  <font class="redC">Answer:-</font>
  ResponseEntity is a real deal. It represents the entire HTTP response. Good thing about it is that you can control anything that
  goes into it. You can specify status code, headers, and body. It comes with several constructors to carry the information you
  want to sent in HTTP Response.
  <br/><br/>
  
  <b class="redC">Question:-What is the use of UriComponentsBuilder</b><br/>
  <font class="redC">Answer:-</font>
  This used for constructing URI. Particularly useful when you want to invoke webservices in your class. Eg:
  <pre class="aa">
  	String baseUri = "/sample-uri"
	UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(uri);
	builder.queryParam("id", "1");
	String uri= builder.build().encode().toUriString();
  </pre>
  It is evident that you can pass additional params, to this. This provide a clean and efficient way of creating uris than writing those as plain text.
  <br/>
  <br/>
  
  
  <b class="redC">Question:-What is the difference between ResponseEntity<T> and @ResponseBody?</b><br/>
  <font class="redC">Answer:-</font>
  ResponseEntity will give you some added flexibility in defining arbitrary HTTP response headers.
  See the constructor here
  <pre class="aa">
  	ResponseEntity(T body, MultiValueMap<String,String> headers, HttpStatus statusCode) 
  </pre>
  If you don't need that, using @ResponseBody will be a tiny bit more concise.
  <br/>
  <br/>
  
  
  <b class="redC">Important annotation of ApacheCXF</b><br/>
  <font class="redC">1:-</font>@WebService<br/>
  <font class="redC">2:-</font>@WebMethod<br/>
  <b class="redC">Question:-</b>What is difference between sessionId and JWT<br/>
  <b class="redC">Answer:-</b><br/>
  <img alt="JWT_Vs_session_ID" src="image/JWT_Vs_session_ID.JPG"><br/>
  <br/>
  <b class="redC">Question:-</b>What is marshalling and unmarshalling in java<br/>
  <b class="redC">Answer:-</b><br/>
  Marshalling is the process of writing Java objects to XML file. Unmarshalling is the process of converting XML content to Java objects<br/>
  <b class="redC">Question:-</b>What is RestController  
  <br/>
  <b class="redC">Answer:-</b><br/>The @Controller is a common annotation that is used to mark a class as Spring MVC<br/> 
  Controller while @RestController is a special controller used in RESTFul web services and the equivalent of @Controller + @ResponseBody.<br/>
  <font class="redC">@RestController = @Controller + @ResponseBody</font>
  <pre class="aa">
  	@RequestMapping(value="/orders", method=RequestMethod.GET)
	@ResponseBody
	public List<Account> accountSummary() {
    	return accountManager.getAllAccounts();
	}
  </pre>
  Now what the annotation means is that the returned value of the method will constitute the body of
  the HTTP response. Of course, an HTTP response can't contain Java objects. So this list of
  accounts is transformed to a format suitable for REST applications, typically JSON or XML.<br/>
  <br/>
  
  <b class="redC">Question:-</b>What is Struts 1 and 2 flow 
  <br/>
  <b class="redC">Note:-</b><br/>
  If you are using struts>=2.1.3 then Action servlet will be StrutsPrepareAndExecuteFilter 
  Otherwise FilterDispatcher will work as Action servlet.<br/>
  <br/>
  <b class="redC">Question:-</b>Difference between struts 1.x and 2.x<br/>
	<b class="redC">Note:-</b><br/>
		Listener is somethings sitting there and wait for specific event to happen 
		, then hijack the event and run it's own event.<br/>	
	<b class="redC">Note:-</b><br/>
		The number inside the <b class="redC">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</b><br/>
		element tells the servlet container in what sequence the servlet 
		should be loaded .lower the numbers are loaded first.if the 
		value is negative or unspecified the servlet container can load 
		servlet any time<br/>
 </div>
 <div data-role="main" class="ui-content">
 <b class="redC">Note:-</b>JAX-RS is a specification for RESTful and Jersey is implementation JAX-RS.<br/>
 <b class="redC">Note:-</b>JAX-WS is specification for SOAP and Apache Axis2 provide the implementation of JAX-WS.<br/>
 Stateless means, every single request from client to server will be considered as a fresh request. Because of this reason REST always prefers to choose HTTP as it a stateless protocol.<br/>
 <font class="redC">JAX-RS Annotations</font><br/>
   1- @Path('Path')<br/>
   2- @GET<br/>
   3- @POST<br/>
   4- @PUT<br/>
   5- @DELETE<br/>
   6- @Produces(MediaType.TEXT_PLAIN [, more-types])<br/>
   7- @Consumes(type[, more-types])<br/>
   8- @PathParam()<br/>
   9- @QueryParam()<br/>
   10-@MatrixParam()<br/>
   11-@FormParam()<br/>
   <font class="redC">@Path() Annotation:-</font><br>
   Its a Class and Method level of annotation This will check the path next to the base URL.<br/>
   <font class="redC">@GET Annotation:-</font><br/>
   Its a method level of annotation, this annotation indicates that the following method should respond to the HTTP GET request only. 
   In general it is use to get data form server because @Produce Annotation will work only on @Get Method. 
   Similary all others will work for specific request<br/>
   <font class="redC">@Produces Annotation</font><br/>
   Its a method or field level annotation, This tells which MIME type is delivered by the method annotated with @GET.<br/>
   <font class="redC">@Consumes Annotation:-</font><br/>
   This is a class and method level annotation, this will define which MIME type is consumed by the particular method.<br/>
   <font class="redC">@PathParam URL Syntax</font><br/>
   http://localhost:7001/RestServiceName/rest/customers/<b>100/Java4s</b><br/>
   <font class="redC">@QueryParam URL Syntax</font><br/>
   http://localhost:7001/…/rest/customers?<b>custNo=100&custName=Java4s</b><br/>
   <font class="redC">@MatrixParam URL Syntax</font><br/>
   http://localhost:7001/…/rest/customers<b>;custNo=100;custName=Java4s</b><br/>
   <font class="redC">@FormParam URL Syntax</font><br/>
   If we have a HTML form having two input fields and submit button. Lets client enter those details and submit to the RESTful web service<br/>
   <br/>
   
    <b class="redC">Question:-</b>How to consume REST Web service in java<br/>
	There is two different way to consume<br/>
	<font class="redC">1-By creating client</font><br/>
	<pre class="aa">
	Client client = ClientBuilder.newClient();
	WebTarget target = client.target("http://host:8080/context/rest/method");
	JsonArray response = target.request(MediaType.APPLICATION_JSON).get(JsonArray.class);
	</pre>
	<font class="redC">2-By http connection(we are using)</font><br/>
	<pre class="aa">
	public class NetClientGet {
    public static void main(String[] args) {
        try {

            URL url = new URL("http://localhost:3002/RestWebserviceDemo/rest/json/product/dynamicData?size=5");//your url i.e fetch data from .
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            conn.setRequestProperty("Accept", "application/json");
            if (conn.getResponseCode() != 200) {
                throw new RuntimeException("Failed : HTTP Error code : "
                        + conn.getResponseCode());
            }
            InputStreamReader in = new InputStreamReader(conn.getInputStream());
            BufferedReader br = new BufferedReader(in);
            String output;
            while ((output = br.readLine()) != null) {
                System.out.println(output);
            }
            conn.disconnect();

        } catch (Exception e) {
            System.out.println("Exception in NetClientGet:- " + e);
        }
    }
}
	</pre>
	
<b class="redC">Question:-</b>Give me the scenario when you go for rest and when you go for soap <br/>
<b class="redC">Answer:-</b><br/>
<font class="redC">1-</font>When you want to validate request data which is possible using xsd in SOAP <br/>
<font class="redC">2-</font>If you are using REST method then it may be case that method that you are using like PUT or PATCH may not support to 
particular browser<br/>
</div>

<div data-role="main" class="ui-content">
<b class="redC">Question:-</b>What are the popular JAX-RS implementations.<br/>
<b class="redC">Answer:-</b><br/>
Some of the popular JAX-RS implementations available today are:<br/>
1-Jersey<br/>
2-RESTEasy<br/>
3-Apache CXF<br/>
4-Restlet<br/>
<b class="redC">Question:-</b>What are the popular JAX-WS implementations.<br/>
<b class="redC">Answer:-</b><br/>
Some of the popular JAX-WS implementations available today are:<br/>
1-Apache CXF<br/>
2-Apache AXIS<br/>
<b class="redC">Question:-</b>What are the most popular JSON processing libraries to work with Java.<br/>
<b class="redC">Answer:-</b><br/>
1-Jackson<br/>
2-GSON<br/>
3-JSON.simple<br/>
4-JSON-P<br/>
But big question is that which should we use 
Jackson is your winning library 
JSON.simple is a nose behind and the other two are in the rearview mirror. <br/>
<b class="redC">Question:-</b>Difference between Jettison and Jackson.<br/>
<b class="redC">Answer:-</b><br/>
Jettison is old.<br/>
Jackson is arguably the standard Java Library for processing JSON.<br/>
 </div>
<div data-role="footer" data-position="fixed">
    <br/>
      <b style="color: red"><a href="CoreJava.html">Core Java</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="Database.html">Database</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="Hibernate.html">Hibernate</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="Spring.html">Spring</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="Struts.html">Struts</a></b>
      <br/>
  </div>
</div>
</body>
</html>
