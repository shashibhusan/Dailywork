<!DOCTYPE html>
<html>
<title>Spring</title>
<head>
<style type="text/css">
.redC {
	color: red
}

.blueC {
	color: blue;
}

table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}
</style>
</head>
<body>

<div data-role="page">
<b class="redC">Scope of singleton object</b><br/>
If the scope is a singleton, then only one instance of that bean will be instantiated per
Spring IoC container and the same instance will be shared for each request.
<br/>
<br/>
  <div data-role="main" class="ui-content">
  <table style="width:1000px" >
<thead>
<tr>
<th>
<p style="text-align:center">BeanFactory</p>
</th>
<th>
<p style="text-align:center">ApplicationContext</p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-It is a fundamental container that provides the basic functionality for managing beans.</td>
<td>1-It is an advanced container that extends the BeanFactory that provides all basic functionality and adds some advanced features.</td>
</tr>
<tr>
<td>2-It supports only Singleton and Prototype bean scopes.</td>
<td>2-It supports all types of bean scopes such as Singleton, Prototype, Request, Session etc.</td>
</tr>
<tr>
<td>3-It does not support Annotations. In Bean Autowiring, we need to configure the properties in XML file only.</td>
<td>3-It supports Annotation based configuration in Bean Autowiring.</td>
</tr>
<tr>
<td>4-In BeanFactory, we need to manually register BeanPostProcessors and BeanFactoryPostProcessors.</td>
<td>4-The ApplicationContext automatically registers BeanFactoryPostProcessor and BeanPostProcessor at startup.</td>
</tr>
<tr>
<td>5-BeanFactory will create a bean object when the getBean() method is called thus making it Lazy initialization.</td>
<td>5-x`ApplicationContext loads all the beans and creates objects at the time of startup only thus making it Eager initialization.</td>
</tr>
</tbody>
</table>
<br/>
<b class="redC">Explaination 3-</b><br/>
<b>BeanFactory Autowiring :</b> <br/>
&lt;bean id="welcomeBean" class="com.geeks.beans.WelcomeBean" autowire="byName"/&gt;<br/>
<br/>
<b>Autowiring in ApplicationContext:</b><br/>
@Autowired<br/>
private String name;<br/>
<br/>
<b class="redC">Explaination 4-</b><br/>
<b>Registering BeanPostProcessors in BeanFactory</b><br/>
 <br/>
ConfigurableBeanFactory factory = new ConfigurableBeanFactory(resource); <br/>
<br/>
HelloBeanPostProcessor bpp = new HelloBeanPostProcessor();<br/>
factory.addBeanPostProcessor(bpp);<br/>
<br/>
<b>Registering BeanPostProcessors in ApplicableContext</b><br/><br/>
An ApplicationContext interface will automatically detect if any beans that are deployed into it implementing the BeanPostProcessor<br/>
simply you need to implement the interface don't need to add it explicity <br/><br/>
public class Department implements BeanPostProcessor {
<br/>
<br/>
 }<br/>
 <br/>
<b class="redC">Question:-</b>What is starter dependency in spring<br/>
<b class="redC">Answer:-</b> 
 A starter dependency is nothing but a special dependency that aggregates commonly used dependencies for a particular feature.<br/> 
<b class="redC">Question-</b>What is use of ObjectMapper class<br/>
<b class="redC">Answer:-</b><br/>
	<b>1-</b> To convert Java Object to JSON<br/>
	<pre style="color:blue">
		ObjectMapper objectMapper = new ObjectMapper(); 
		Car car = new Car("yellow", "renault");
		objectMapper.writeValue(new File("target/car.json"), car);
		</pre>	
	<b>2-</b> To JSON to Java Object <br/>
	<pre style="color:blue">
		String json = "{ \"color\" : \"Black\", \"type\" : \"BMW\" }"; 
		Car car = objectMapper.readValue(json, Car.class); 	 
		</pre>
<b class="redC">Question-</b>What is working of Stream API<br/>
<b class="redC">Answer:-</b> 
Stream represents a sequence of objects from a source  
then we applied Intermediate Operations & Terminate Operations to get the output<br/>
 <b class="redC">Question-</b>Example of Spring Boot - Interceptor in spring Boot<br/>
  <b class="redC">Answer:-</b><br/>
	1-preHandle() method - 
	This is used to perform operations before sending the request to the controller. 
	This method should return true to return the response to the client.<br/>
	2-postHandle() method - 
	This is used to perform operations before sending the response to the client.<br/>
	3-afterCompletion() method - 
	This is used to perform operations after completing the request and response.<br/>
	
  <b class="redC">Question-</b>How to read value from properties files in spring Boot<br/>
  <b class="redC">Answer:-</b><br/>
  <pre style="color:blue">
  @Value("${project.name}") 
    private String projectName; 
	</pre>	
	and entry inside properties file will be like below<br/>
	 <pre style="color:blue">
	project.name = JavaApplicationProject  
	</pre>
	But if we use yml file then we can map other data types like List & Map <br/>
	<pre style="color:blue">
@Component
@ConfigurationProperties(prefix = "application")
public class ApplicationClass {
    List<String> profiles;
    HashMap<String,Integer> hashMap=new HashMap();
    @Value("${applicationTest}")
    String applicationTest;
	// getter & setter
	}
	
	Then application.yml
application:
  profiles:
    - dev
    - test
    - prod
    - 1
    - 2

  hashMap:
    raghu:  20
    shashi: 21
    setty:  25

applicationTest : applicationTest
	</pre>
<b class="redC">Note-</b>
The ApplicationProps class needs to be decorated with @ConfigurationProperties to express the intention of mapping the YAML properties<br/> 
 	
  <b class="redC">Question-</b>Avantages & Disadvantages of spring container<br/>
  <b class="redC">Avantages</b><br/>
	  <b>1-</b>Forces you to write more modular code<br/>
	  <b>2-</b>Decouples the application<br/>
	  <b>3-</b>Centralized configuration<br/>
	  <b>4-</b>Control over lifetime of dependencies<br/>
	  <b>5-</b>Takes care of long nested dependency chains<br/>
  
  <b class="redC">Disadvantages</b><br/>
	  <b>1-</b>Another framework in your toolbox (another mindset to adapt)<br/>
	  <b>2-</b>Hard to figure out the flow in the application. As in, what is the actual<br/>
	  <b>3-</b>No build errors - requires some way of testing dependencies together (yes not unit tests)<br/>
	  <b>4-</b>Requires configuration of dependencies.<br/>
  
    <b class="redC">Question-</b>Avantage of annotation over XML configuration in java<br/>
	<b class="redC">Answer:-</b><br/>
	Advantages of the annotation:<br/>
		<b>1-</b> All the information is in a single file (no need to open two files to configure a given behavior)<br/>
		<b>2-</b> When the class changes, no need to modify the xml file<br/>
	Advantages of xml file:<br/>
    	<b>1-</b>Clear separation between the POJO and its behavior<br/>
    	
  <b class="redC">Spring Security</b><br/>
  When you want to use Spring Security before spring 3.0 then you have to extends WebSecurityConfigurerAdapter
  in our configuration class which provide overided configure() method that used for Authentication & Authorization
  Method for Authentication method takes AuthenticationManagerBuilder as argument and Authorization method takes
  HttpSecurity as argument as given Below<br/>
  <pre style="color:blue">
  public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

   @Override //<b>Authentication method</b>
   protected void configure(AuthenticationManagerBuilder auth) throws Exception {
      auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
   }
 
   @Override //<b>Authorization method</b>
   protected void configure(HttpSecurity http) throws Exception {
      http.csrf().disable()
      .authorizeRequests().antMatchers("/login").permitAll()
      .anyRequest().authenticated()
      .and()
      .exceptionHandling().authenticationEntryPoint(authenticationEntryPoint)
      .and()
      .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
      http.addFilterBefore(filter, UsernamePasswordAuthenticationFilter.class);
   }
}
  </pre>
	 <b class="redC">Principal:-</b>Means currently login user into system.It is the information about currently login user.Actually,
	 It is object that contain information about currently login user.<br/>

	 <b class="redC">Note:-</b>
	 <b>@EnableWebSecurity:-</b>It tells the spring that it is a web security configuration<br/>
 
	 
	 <b class="redC">Question:-</b>How to set passwordEncoder<br/>
	 <b class="redC">Answer:-</b>Just expose a bean of type passwordEncoder <br/>
	 <pre style="color:blue">
	 @Bean
		public PasswordEncoder passwordEncoder() {
			return new BCryptPasswordEncoder();
		}
	 </pre>

  <b class="redC">Note:-</b> 
  If you want to change the dataSource infromation then you can pass that information in <b>application.properties</b><br/>
  <pre style="color: blue">
  spring.dataSource.url= 
  spring.dataSource.userName= 
  spring.dataSource.password= 
  </pre>
 
 <b class="redC">Constructor based dependency:-</b>
  Constructor based dependency injection using spring annotation<br/>
	<pre style="color:blue">
   Constructor based DI and Autowire by constructor Example
   @Autowired
   public Company(Employee employee) {
      this.employee = employee;
   }
 	</pre>
 <b class="redC">Question:-</b>Advantage of jdbcTemplate over Hibernate<br/>
 <b>1-</b>Hibernate create some extra overhead.<br/>
 <b>2-</b>Hibernate is not intended for batch-jobs.<br/>
 Make this entry<br/>
 <pre  class="blueC">
 &lt;property name="hibernate.jdbc.batch_size"&gt; 50 &lt;/property&gt;
  then 
    for ( int i=0; i&gt;100000; i++ )
  {
            String studentName = "DINESH " + i;
            int rollNumber = 9 + i;
            String course = "MCA " + i;
            Student student = new Student();
            student.setStudentName(studentName);
            student.setRollNumber(rollNumber);
            student.setCourse(course);
            session.save(student);
          if( i % 50 == 0 ) //Imprtant 
          {
               session.flush();
               session.clear();
            }
  }
you can do this but is not intended for batch-jobs.
</pre> 	
  <b class="redC">Question:-</b>What are the stereotype annotation in spring.
  @Component is a generic stereotype annotation for any Spring-managed component<br/>
  This means that if you want to register a class in the application context you can use @Component to do so
  The other stereotypes (Controller, Service, Repository) are simply specializations of the @Component class<br/> 
  <b class="redC">HandlerInterceptor in Spring Boot</b><br/> 
  <b class="redC">Step:-1 Create custom handler</b>
  <pre  class="blueC">
  @Component
	public class CustomInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(
            HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        log.info("**************This is preHandle method ************");
        return true;
    }
    @Override
    public void postHandle(
            HttpServletRequest request, HttpServletResponse response, Object handler,
            ModelAndView modelAndView) throws Exception {
        log.info("**************This is postHandle method *************");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                                Object handler, Exception exception) throws Exception {
        log.info("**************This is afterCompletion method ***************");
    }
}
  </pre>
  <b class="redC">Step:-2 Register the custom handler </b> <br/>
  <pre  class="blueC">
  @Configuration
	public class InterceptorConfiguration implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new CustomInterceptor());
    }
}
  </pre>
	<b class="redC">Exception handling in Spring Boot</b><br/>
	1-@ExceptionHandler<br/>
	2-@ControllerAdvice<br/>
	<b class="redC">@ExceptionHandler:-</b><br/>
	This is used at controller level so we need use for every controller<br/>
	<pre  class="blueC">
		@ExceptionHandler(value=Exception.class)	
 		@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) 
		  public String handleException () {
			 System.out.println(" inside ExceptionHandling.java.handleException() at controller level");
		     return "exceptionExample";
		  }
	</pre>
	<b class="redC">@ControllerAdvice:-(There is no extra configuration required)</b><br/>
	This is golobal way of handling Exception <br/>
	<pre  class="blueC">
	@ControllerAdvice 
	public class ExceptionHandlingControllerAdvice {
	
	@ResponseStatus(HttpStatus.NOT_FOUND)
	@ExceptionHandler(value=Exception.class)	
		public ModelAndView handleException()
		{
			System.out.println("ExceptionHandlingControllerAdvice.handleException()");
			return new ModelAndView("exceptionExample");
		}
	}
	</pre>	
   <b class="redC">If we use both then preority order will be</b><br/>
    @ExceptionHandler<br/>
	@ControllerAdvice<br/>		
 </div>
 <div data-role="main" class="ui-content">
 <b class="redC">Question:-</b>What is Spring<br/>
 The Spring framework is a Java platform that provides comprehensive infrastructure support for developing Java applications.<br/> 
 <b class="redC">Question:-</b>What are the feature of Spring framework<br/>
 <b class="redC">1-</b>Inversion of control (IOC):- Means inversion of control , Spring IOC is responsible for instantiating, configuring and assembling objects known as beans <br/>
 <b class="redC">2-</b> Aspect oriented (AOP):- is used for separating cross-cutting concerns from the business logic of the application.<br/>
 <b class="redC">3-</b> Dependency Injection(DI) <br/>
 <b class="redC">4-</b> MVC Framework:- Spring comes with MVC web application framework<br/>
 <b class="redC">5-</b> Transaction Management <br/>
 <b class="redC">Transaction Management in Spring Boot</b><br/>
 Steps to use @Transactional in Spring Boot<br/>
 <b class="redC">1-</b>@EnableTransactionManagement to your main class of Spring Boot application.<br/>
 <b class="redC">2-</b>Use @Transactional annotation on class level or method level.<br/>
 @Transactional can be annotated not only on methods but also on
 classes. When annotated on a class, all public methods of that class are
 transaction-enabled. If both class-level and method-level
 @Transactional annotations are used, the annotation used at the method
 evel overrides the class-level annotation.</br>
 <b class="redC">Attributes of the @Transactional annotation</b><br/>
 <b>@Transactional(propagation = Propagation.REQUIRED):</b><br/>
 By default, the @Transactional annotation will create a new transaction for
 the marked method or class if one does not already exist. If a transaction
 does already exist, the marked method or class will be executed within the existing transaction.
 you can specify that a transaction should always be created, regardless of whether a transaction already exists,
 by using the PROPAGATION_REQUIRED attribute:@Transactional(propagation = Propagation.REQUIRED)
	<br/><br/>
<b>@Transactional(isolation = Isolation.SERIALIZABLE):</b><br/>
You can also specify the isolation level of a transaction by using the
isolation attribute. The isolation level determines how much a transaction
is isolated from other transactions. For example, you can use the
ISOLATION_SERIALIZABLE attribute to specify that the transaction should be completely isolated from other transactions:
@Transactional(isolation = Isolation.SERIALIZABLE)<br/>
	<br/><br/>
<b>@Transactional(timeout = 10):</b><br/>
You can also specify the maximum time that a transaction should take to complete by using the timeout attribute.
<br/><br/>
<b>@Transactional(rollbackFor = { SQLException.class }):</b><br/>
which can be used to specify the exceptions that should cause a transaction to roll back. 
<br/><br/>
<b>@Transactional(readOnly = true):</b><br/>	
The @Transactional annotation also supports other attributes, such as readOnly, which can be used to indicate that a transaction should be read-only
<br/><br/>
 <b class="redC">Question:-</b> Which are the Spring framework modules<br/>
 <b class="redC">Answer:-</b>Modules of Spring Architecture<br/>
 <b class="redC">1-Core Container</b><br/>
	(i)-Core<br/> 
	(ii)-Bean<br/>
	(iii)-Context<br/>
	(iv)-Expression language<br/>
<b class="redC">2-Data Access</b><br/>
	(i)JDBC module<br/>
	(ii)ORM<br/>
	(iii)Transaction Management module<br/>
<b class="redC">3-Web module</b><br/>
	(i)Web module<br/>
	(ii)Web-MVC module<br/>
<b class="redC">4-Miscellaneous module</b><br/>
	(i)AOP<br/>
	(ii)Aspects Spring module<br/> 
	(iii)Messaging module<br/>
 
 <b class="redC">Question:-</b>Explain Bean life cycle in Spring framework<br/>
 <img src="image/spring-bean-life-cycle-management-example.png" alt="Spring bean life cycle"><br/>
 <b class="redC">Note:-</b><br/>
 The three commonly used implementations of ApplicationContext are<br/>
 <b class="redC">1-</b>ClassPathXmlApplicationContext<br/> 
 <b class="redC">2-</b>FileSystemXmlApplicationContext<br/> 
 <b class="redC">3-</b>XmlWebApplicationContext<br/>
 <b class="redC">In how many ways, you can configure Spring into our application?</b><br/>
 <b class="redC">1-</b>XML Based Configuration<br/>
 <b class="redC">2-</b>Annotation-based configuration<br/>
 <b class="redC">3-</b>Java-based configuration<br/>
 <b class="redC">What is Spring Java-Based Configuration?</b><b>Core Application</b><br/>
 To instantiate such config, you will need the help of AnnotationConfigApplicationContext class.<br/>
 <pre>
	 public static void main(String[] args) {
	    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
	    MyService myService = ctx.getBean(MyService.class);
	    myService.doStuff();
	}
 </pre>
 To enable component scanning, just annotate your @Configuration class as follows:<br/>
 <pre>
	@Configuration
	@ComponentScan(basePackages = "com.howtodoinjava")
	public class AppConfig  {
	    ...
	}
 </pre>
 If you are using above configuration in a <b class="redC">web application</b> then you will be using<br/>
 <b class="redC">AnnotationConfigWebApplicationContext</b> class. This implementation may be used when configuring<br/> 
 the Spring ContextLoaderListener servlet listener, Spring MVC DispatcherServlet etc.<br/>
 <b class="redC">Example:-</b><br/>
 
 	<pre>
	 	&lt;web-app&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            <b class="redC">org.springframework.web.context.support.AnnotationConfigWebApplicationContext</b>
        &lt;/param-value&gt;
    &lt;/context-param&gt;
 
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;<b class="redC">com.howtodoinjava.AppConfig</b>&lt;/param-value&gt;
    &lt;/context-param&gt;
 
    &lt;<b class="redC">!-- Bootstrap the root application context as usual using ContextLoaderListener</b>--&gt;
    &lt;listener&gt;
        &lt;<b class="redC">listener-class&gt;org.springframework.web.context.ContextLoaderListener</b>&lt;/listener-class&gt;
    &lt;/listener&gt;
 
    &lt;<b class="redC">!-- Declare a Spring MVC DispatcherServlet as usual --</b>&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextClass&lt;/param-name&gt;
            &lt;param-value&gt;
                <b class="redC">org.springframework.web.context.support.AnnotationConfigWebApplicationContext</b>
            &lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;<b class="redC">com.howtodoinjava.web.MvcConfig</b>&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
 
    &lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;&gt;
 	</pre>
 <b class="redC">Explain Spring Bean lifecycle?</b><br/>
 <b class="redC">Question :-</b>Are Singleton beans thread safe in Spring Framework 
 Spring framework does not do anything under the hood concerning the multi-threaded behavior of a  
 singleton bean. It is the developer’s responsibility to deal with concurrency issue and thread safety of 
 the singleton bean.<br/>
 <b class="redC">Question:-</b>Name some of the design patterns used in Spring Framework?<br/>
 <b class="redC">1-</b>Proxy <br/>
 <b class="redC">2-</b>Singleton<br/> 
 <b class="redC">3-</b>Template method<br/>
 <b class="redC">4-</b>Front Controller<br/>
 <b class="redC">5-</b>View Helper<br/>
 <b class="redC">6-</b>Dependency injection<br/>
 <b class="redC">7-</b>Factory pattern<br/>
 <b class="redC">Question:-</b>Which DI would you suggest Constructor-based or setter-based DI? 
 You can use both Constructor-based and Setter-based Dependency Injection. The best 
 solution is using constructor arguments for mandatory dependencies and setters for optional 
 dependencies.<br/>
 <b class="redC">Question:-</b>Are there limitations with autowiring?<br/>
 <b>Primitive data types:</b> You cannot autowire simple properties such as primitives, Strings, and Classes.<br/>
 <b>Confusing nature:</b> Autowiring is less exact than explicit wiring, so if possible prefer using explicit wiring. <br/>
 <b class="redC">Can you inject null and empty string values in Spring?</b><br/>
 Yes, you can.<br/>
 <b class="redC">Question :-</b> DispatcherServlet<br/>
 The Spring Web MVC framework is designed around a DispatcherServlet that handles all the <br/>
 HTTP requests and responses.<br/>
 <b class="redC">Question:-</b>What is a Proxy?<br/>
 <b>Question:-</b>What are the different types of AutoProxying?<br/>
 <b class="redC">1-</b>BeanNameAutoProxyCreator<br/>
 <b class="redC">2-</b>DefaultAdvisorAutoProxyCreator<br/>
 <b class="redC">3-</b>Metadata autoproxying<br/>
 <b class="redC">Question:-</b>How can we integrate Spring and Hibernate using HibernateDaoSupport?<br/>
 <b class="redC">Question:-</b>Types of the transaction management Spring support<br/>
 <b class="redC">1-Programmatic transaction management:</b><br/>
	 This means that you have managed the transaction with the help of programming. 
	 That gives you extreme flexibility, but it is difficult to maintain.<br/>
 <b class="redC">2-Declarative transaction management:</b><br/> 
	 This means you separate transaction management from the business code. 
	 You only use annotations or XML based configuration to manage the transactions.<br/>
 <b class="redC">Question:-</b> Which Transaction management type is more preferable?<br/>
 <b class="redC">Answer :-</b>Declarative transaction management<br/>
 <b class="redC">Question:-</b>Can we have multiple Spring configuration files in one project<br/>
 	Yes, in large projects, having multiple Spring configurations is recommended to increase maintainability and modularity.<br/>
 	You can load multiple Java-based configuration files:<br/>
 <pre>
	 @Configuration
	@Import({MainConfig.class, SchedulerConfig.class})
	public class AppConfig {
	.....
	}
 </pre>
  Or load one XML file that will contain all other configs:<br/>
  ApplicationContext context = new ClassPathXmlApplicationContext("spring-all.xml");<br/>
  and in spring-all.xml we can include multiple files.<br/>
 </div>
 <div data-role="main" class="ui-content">
 <b class="redC">Internationalization (i18n) in Spring </b><br/>
 Steps to use Internationalization in Spring <br/>
 <b class="redC">Step:-1</b><br/>
 <b class="redC">At JSP page</b><br/>
 <pre>
 	&lt;tr&gt;
		&lt;td&gt;&lt;spring:message code="<b class="redC">first.name</b>"&gt;&lt;/spring:message&gt;&lt;/td&gt;
		&lt;td&gt;&lt;input type="text" name="fname"/&gt;&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;spring:message code="last.name"&gt;&lt;/spring:message&gt;&lt;/td&gt;
		&lt;td&gt;&lt;input type="text" name="lname"/&gt;&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;spring:message code="mobile.number"&gt;&lt;/spring:message&gt;&lt;/td&gt;
		&lt;td&gt;&lt;input type="text" name="mobile"/&gt;&lt;/td&gt;
	&lt;/tr&gt;
	</pre>
 <b class="redC">Step:-2</b><br/>
 <pre>
 &lt;a href="hello.shashi?<b class="redC">siteLanguage</b>=en"&gt;English&lt;/a&gt;<br/> 
 &lt;a href="hello.shashi?siteLanguage=fr"&gt;French&lt;/a&gt;<br/> 
 </pre>
 <b class="redC">Step:-3</b><br/>
 <pre>
    &lt;mvc:interceptors&gt;
	&lt;bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"&gt;
	&lt;property name="<b class="redC">paramName</b>" value="<b class="redC">siteLanguage</b>"&gt;&lt;/property&gt;
	&lt;/bean&gt;
	&lt;/mvc:interceptors&gt;
	
	&lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver"&gt;
	&lt;/bean&gt;
	
	&lt;bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;
	&lt;property name="basename" value="/WEB-INF/<b class="redC">shashi</b>"&gt;&lt;/property&gt;	
	&lt;/bean&gt;
 
 </pre>
	 <b class="redC">Step:-4</b><br/>
	 properties files<br/>
	 <b class="redC">shashi_en.properties</b><br/>
	 <b class="redC">shashi_fr.properties</b><br/>
	 and content of the file <br/>
	 <b class="redC">first.name=Prénom</b><br/>
	 last.name=Nom de famille<br/>
	 mobile.number=téléphone portable<br/>
 </div>
<div data-role="main" class="ui-content">
<b class="redC">How to use tiles in Spring MVC</b><br/>
<pre>
&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.tiles3.TilesViewResolver"/&gt;
	&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer"&gt;
		&lt;property name="definitions"&gt;
		&lt;list&gt;
		&lt;value&gt;/WEB-INF/tiles.xml&lt;/value&gt;
		&lt;/list&gt;
		&lt;/property&gt;  
	&lt;/bean
</pre>
<b class="redC">and then tiles.xml file</b><br/>
<pre>
&lt;tiles-definitions&gt;
	&lt;definition name="base.definition"
		template="/WEB-INF/jsp/layout.jsp"&gt;
		&lt;put-attribute name="title" value="" /&gt;
		&lt;put-attribute name="header" value="/WEB-INF/jsp/header.jsp" /&gt;
		&lt;put-attribute name="menu" value="/WEB-INF/jsp/menu.jsp" /&gt;
		&lt;put-attribute name="body" value="" /&gt;
		&lt;put-attribute name="footer" value="/WEB-INF/jsp/footer.jsp" /&gt;
	&lt;/definition&gt;

	&lt;definition name="loginPage" extends="base.definition"&gt;
		&lt;put-attribute name="title" value="Home Page" /&gt;
		&lt;put-attribute name="body" value="/WEB-INF/jsp/body.jsp" /&gt;
	&lt;/definition&gt;
&lt;/tiles-definitions&gt;
</pre>
</div>
<div data-role="main" class="ui-content">
<b class="redC">How to make database connection in Spring MVC</b><br/>
<b class="redC">Step:1-Creating dataSource</b><br/>
<pre>
		&lt;bean id="<b class="redC">dataSource</b>" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
		&lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt;
		&lt;property name="url" value="jdbc:mysql://localhost:3306/test" /&gt;
		&lt;property name="username" value="root" /&gt;
		&lt;property name="password" value="220047" /&gt;
		&lt;/bean&gt;
</pre>
<b class="redC">If you want to use simple mysql for database transaction</b><br/>
<pre>
&lt;bean id="ConnectionMgnDAO" class="com.connection.ConnectionMgn"&gt;
		&lt;property name="dataSource" ref="<b class="redC">dataSource</b>" /&gt;
		&lt;/bean&gt;
	</pre>
<b class="redC">If you want to use spring jdbc template for database transaction</b><br/>
<pre>
&lt;bean id="jt" class="org.springframework.jdbc.core.JdbcTemplate"&gt;  
		&lt;property name="dataSource"  ref="<b class="redC">dataSource</b>"&gt;&lt;/property&gt;  
		&lt;/bean&gt;
</pre>
<b class="redC">and Then</b><br/>
<pre>
&lt;bean id="dao" class="com.model.EmpDao"&gt;  
		&lt;property name="template" ref="<b class="redC">jt</b>"&gt;&lt;/property&gt;  
		&lt;/bean
</pre>		
</div>

  <div data-role="main" class="ui-content">
  <b class="redC">Use of Spring Tags :-</b><br/>
  The Spring MVC form tags are very basic indeed, but they're better than nothing. If you're trying to render HTML forms, with submissions, error messages, and resubmissions, they take a lot of the annoyance away (especially for 'select' fields, which are a huge pain to handle otherwise).
  For anything more complex, they're pretty useless, but for forms, I see no reason to not use them.<br/>
  Another benefit of spring tags is that when you make a mistake and you write the name of a property which doesn't exist in the object to populate it gives you an error, so you can easily find-out that you have to correct the name of the property in the path attribute of the tag.
  </div> 
  
  <div data-role="main" class="ui-content">
  <b class="redC">What is IOC:-</b><br/>
  In Spring framework, IOC container is responsible to inject the dependency. We provide metadata to the IOC container either by XML file or annotation
  </div>
  <br/>
  <div data-role="main" class="ui-content">
  <b class="redC">Dependency Injection in Spring:-</b>
  Dependency Injection (DI) is a design pattern that removes the dependency from the programming code so that it can be easy to manage.
  and provide it using XML etc.
  </div>
  
  <div data-role="main" class="ui-content">
  <b class="redC">Dependency Lookup :-</b>
  The Dependency Lookup is an approach where we get the resource after demand.
  Problem with this a approach is that if dependency will change then it require lot of changes.
  <br/>
  <b class="redC">Spring framework provides two ways to inject dependency</b><br/>
  1-By Constructor <br/>
  2-By Setter method<br/>
  </div>
  <div data-role="main" class="ui-content">
  <b class="redC">Difference between constructor and setter injection</b><br/>
  <b class="redC">Partial dependency:</b>can be injected using setter injection but it is not possible by constructor. Suppose there are 3 properties in a class, having 3 arg constructor and setters methods.<br/>
  In such case, if you want to pass information for only one property, it is possible by setter method only<br/>
  <b class="redC">Overriding:</b>Setter injection overrides the constructor injection. If we use both constructor and setter injection, IOC container will use the setter injection.
  </div>
  
  <div data-role="main" class="ui-content">
  <b class="redC">AutoWiring  is the feature to inject the dependency implicitly</b><br/>
  <b class="redC">Advantage is</b><br/>
  It requires the less code because we don't need to write the code to inject the dependency explicitly.<br/>
  <b class="redC">Disadvantage is</b> <br/>
  It is applicable for only object reference not for primitive data type.<br/>

  <b class="redC">Type of Autowiring:-</b><br/>
  <b class="redC">1-byName:-</b>In case of byName autowiring mode, bean id and reference name must be same<br/>
  <b class="redC">2-byType :-</b>In case of byType autowiring mode, bean id and<br/> 
   reference name may be different. But there must be only one bean of a type<br/>
   <b class="redC">3-byConstructor:-</b><br/>
   In case of constructor autowiring mode, spring container injects the dependency by highest parameterized constructor.<br/>
   This mode is very similar to byType, but it applies to constructor arguments.<br/>
   
   Spring container looks at the beans on which autowire attribute is set constructor in the XML configuration file. <br/>
   It then tries to match and wire its constructor's argument with exactly one of the beans name in the configuration file.<br/>
    
   </div>
  <div data-role="main" class="ui-content">
  <b class="redC">Note:-</b><br/>
   @Autowired 
   is equivalent to  Autowiring byType<br/>
   <br/>

  </div>
  
  <div data-role="main" class="ui-content">
  
  <b class="redC">@ResponseBody</b><br/>
  <pre class="blueC">
		@RequestMapping(value="/orders", method=RequestMethod.GET)
		@ResponseBody
		public List<Account> accountSummary() {
		    return accountManager.getAllAccounts();
		}
  </pre>
  Now what the annotation means is that the returned value of the method will constitute the body
  of the HTTP response. Of course, an HTTP response can't contain Java objects. So this list of  
  accounts is transformed to a format suitable for REST applications, typically JSON or XML.<br/><br/>
  
  <b class="redC">@Component :-</b>is a class level annotation and its purpose is to make the class as spring managed component<br/> 
  <b class="redC">@Bean:-</b> is a method level annotation and is used to explicitly declare and register a bean<br/>
  <b class="redC">Difference between @Component, @Service, @Controller, and @Repository in Spring
  </b><br/>
  
  @Component is a generic annotation,
  Difference of @Service, @Repository, @Controller with @Component is they are special cases of @Component and used for particular purposes 
  The difference is just classification only.<br/>
  <br/>
  <b class="redC">@Controller:-</b>is an annotation used in Spring MVC framework indicates that a particular class serves the role of a controller 
  Then the dispatcher scans such annotated classes for mapped methods and detects @RequestMapping annotations<br/>
  
  <b class="redC">Note:-</b><br/>
  Difference of @Service, @Repository, @Controller with @Component is they are special cases of 
  @Component and used for particular purposes where as @Component is a generic annotation<br/>
  </div>
  
  <div data-role="main" class="ui-content">
  <b class="redC">Bean:-</b>is a java object that is managed by IOC container.<br/>
  <b class="redC">Note:-</b>The Spring container is responsible for instantiating, configuring, and assembling the Spring beans<br/>
  
  <b class="redC">BeanFactory VS ApplicationContext</b><br/>
  BeanFactory is also called basic IOC and ApplicationContext is called Advanced IOC because it extends 
  the BeanFactory so it cantain all the feature of BeanFactory and some extra feature that is why it is known 
  as Advanced IOC<br/><br/>
  
  It uses eager loading, so every bean instantiate after the ApplicationContext is started up, where as BeanFactory  
  uses lazy loading.So we use BeanFactory when memory consumption might be critical because it will load the 
  object when it will be require. 
  ApplicationContext instantiate bean when started so consume memory but works fast. 
  and also BeanFactory is lightweight.<br/>
  
  
  <b class="redC">ApplicationContext have some extra feature</b><br/>
    1)Bean instantiation/wiring<br/>
    2)Automatic BeanPostProcessor registration<br/>
    3)Automatic BeanFactoryPostProcessor registration<br/>
    4)Convenient MessageSource access (for i18n)<br/>
    5)ApplicationEvent publication<br/>
	<br/>
	<b class="redC">Important</b>
    Spring does a lot of magic on return types , but also on the parameter 
	types. This allow you to write code in a style that is more intuitive  
	for you. ie the following two example are same<br/>
	
	<pre>@RequestMapping(value="/)
	public ModelAndView mainPage()
	{
		Model m=new Model();
		m.put("key","value");
		return new ModelAndView(m,"main");
	}
	<b class="redC">AND</b>
	@RequestMapping(value="/)
	public ModelAndView mainPage(Model m)
	{
		m.put("key","value");
		return "main";
	}
	</pre>
	</div>
 <div data-role="main" class="ui-content">
	<b class="redC">What is Enumeration :-</b> <br/>
	Enumeration is a interface define the method by which you can enumerate the element in a collection of object.<br/>
	Enumeration define two Methods<br/>
	1)-Boolean hasMore Element().<br/>
	2)-object nextElement().<br/>
	<br/>
  </div>
 
  <div data-role="main" class="ui-content">
  <b class="redC">About name and location of applicationContext.xml:-</b><br/>
  Yes we can change the name and location of applicableContext.xml file(<b class="redC">if you are using xml</b>) 
  If it is a basic application then by default it will be inside src folder directly 
  and if we want to change the name and location then it will be like given below<br/>
  
  <pre class="blueC">
	  <b class="redC">ApplicationContext context = new ClassPathXmlApplicationContext("config/weCanchangeNameAndLocation.xml");</b> 
	  Student stBean = (Student) context.getBean("studentbean"); 
	  System.out.println("then prpperty of the bean : "+stBean.getName()); 
  </pre>
  
  <b class="redC">If you are using BeanFactory</b><br/>
  <pre class="blueC">
	  Resource resource=new ClassPathResource("config/weCanchangeNameAndLocation.xml");
	  BeanFactory factory=new XmlBeanFactory(resource);
	  Student stBean1 =(Student)factory.getBean("studentbean");
	  System.out.println("the propery of the bean :"+stBean1.getName());
  </pre>
  
 <b class="redC">InCase of annotation :-</b><br/>
 <pre <pre class="blueC">
	AbstractApplicationContext context = new AnnotationConfigApplicationContext(ConfigurationClass.class);
	Student st=(Student)context.getBean("studentBean");
	and ConfigurationClass class will be like
	@Configuration
	@ComponentScan("com.bean")
	public class ConfigurationClass {
		@Autowired
		private Employee employee;
		@Bean(name="studentBean")
		public Student shashi()
		{
			return new Student();
		}
	}
</pre>	
 </div>
  <div data-role="main" class="ui-content">
  <b class="redC">If it is web application :</b><br/>
  if you have applicableContext.xml file and spring-servlet.xml file 
  then bean define in applicableContext.xml file will be global while define in spring-servlet 
  will be available for this servlet only 
  Then we can put this file in : webContent/WEB-INF/applicableContext.xml
  if you want to change the location then made the below entry in web.xml file like this<br/>
  
  <pre class="blueC">
		&lt;context-param&gt;
		&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
		&lt;param-value&gt;/WEB-INF/conf/ApplicationContext.xml&lt;/param-value&gt;
		&lt;/context-param&gt;
  </pre>
  
  But<br/>
  best solution is that put applicableContext.xml file anywhere  use <br/>
  <b class="redC">ApplicationContext ac = new FileSystemXmlApplicationContext("src/WEB-INF/config/applicationContext.xml");</b><br/>
  </div>	
   <div data-role="main" class="ui-content">
   <b class="redC">Now use of spring-servlet.xml to file to satatisfy dependency , code as below</b><br/>
   
   <pre class="blueC">
		   public class ConnectionMgn { 
				private DataSource dataSource; 
				// This is the setter for dataSource
				public void setDataSource(DataSource dataSource) { 
			    this.dataSource = dataSource;<br/>
				// now you can use dataSource to get connection. 
			} 
	</pre>
	and then spring-servlet.xml<br/>
	<pre class="blueC">
			&lt;bean id="ConnectionMgnDAO" class="com.connection.ConnectionMgn"&gt; 
				&lt;property name="dataSource" ref="dataSource" /&gt; 
			    &lt;/bean&gt;
			if you want to use this class in other class then you can use
			@Autowired 
			ConnectionMgn Mgn; 
			then use Mgn. 
			<b class="redC">Note:- But in case of other beans where we no need of satatisfy dependency</b>  
			simply use  
			@Autowired 
			Student  st; 
			 
		  	<b class="redC">inside a class you will get the object</b> 
		  	<b class="redC">Student class as below :-</b>
		  	
		   @Component 
		   public class Student { 
			private String name; 
			public String getName() { 
				return name; 
			} 
			public void setName(String name) { 
				this.name = name; 
			} 
			</pre> 
 </div>
 
  <div data-role="main" class="ui-content">
   <b class="redC">Important :-</b><br/>
   BeanFactory interface &lt;---- ApplicationContext interface &lt;----- WebApplicationContext interface<br/>
   Mean BeanFactoryis root interface.<br/>
   <b class="redC">ApplicationContext:-</b><br/>
   is Root Application Context and there will be only one applicationContext per web application.
   Application Context is the context initialized by a ContextLoaderListener 
   or ContextLoaderServlet that we define in our application’s web.xml file and the 
   configuration would look something like this
   <pre>
   	&lt;listener&gt;
	&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
	&lt;/listener&gt;
 
	&lt;context-param&gt;
	&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
	&lt;param-value&gt;/WEB-INF/root-context.xml&lt;/param-value&gt;
	&lt;/context-param&gt;
   </pre> 
   In the above configuration, we are asking Spring to load root-context.xml and create an 
   Application Context from it. If contextConfigLocation is not mentioned as in the below 
   snippet, it will by default look for /WEB-INF/applicationContext.xml.
   <pre>
  	&lt;listener&gt;
	&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
	&lt;/listener&gt;
   </pre>
   <b class="redC">WebApplicationContext:-</b><br/>
   It has servlet context information.
   A single web application can have multiple WebApplicationContext and each Dispatcher servlet 
   is associated with a WebApplicationContext.
   and is loaded based on the dispatcher servlets configured in the application’s web.xml file.
   So each dispatcher servlet has its own servlet-context initialized from 	&lt;servlet-name&gt;-servlet.xml file. This allows
   us to categorize the incoming requests based on the servlet’s url-pattern and handle them accordingly
   <pre>
   	&lt;servlet&gt;
	&lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;
	&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
	&lt;init-param&gt;
		&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
		&lt;param-value&gt;/WEB-INF/sample-dispatcher-servlet.xml&lt;/param-value&gt;
	&lt;/init-param&gt;
	&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
	&lt;/servlet&gt;
	
	&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/&lt;/url-pattern&gt;
	&lt;/servlet-mapping&gt;
   </pre>  
   <b class="redC">Note:-</b>Dependency Injection is passing dependency to other objects.<br/>
 </div>
  <div data-role="main" class="ui-content">
  <b>XmlWebApplicationContext class:-</b>Is a implemetation class of WebApplicationContext interface.<br/> 
  <b class="redC">Important :-</b><br/>
  default-autowire="byName" default-autowire-candidates="*" ><br/>
  Beans element <b class="redC">default-autowire</b>is used to define the default autowiring method.<br/>
  Here I am defining the default autowiring method to be byName.<br/>
  
  Beans element <b class="redC">default-autowire-candidates</b> is used to provide the pattern for bean names that can be used for autowiring. <br/>
  For simplicity I am allowing all the bean definitions to be eligible for autowiring.<br/>
  <pre>
  &lt;bean name="employee1" class="com.journaldev.spring.autowiring.model.Employee" <b class="redC">autowire-candidate="false"</b>&gt;&lt;br/&gt;
  &lt;property name="name" value="Dummy Name"&gt;&lt;/property&gt; 
  &lt;/bean&gt;
  </pre>
  <b class="redC">autowire-candidate="false"</b> is used in a bean definition to make it ineligible for autowiring.<br/>
  It is useful when we have multiple bean definitions for a single type and we want some of them not to be autowired.<br/>
  
 </div>
 
  <div data-role="main" class="ui-content">
  <b class="redC">Dependency Injection using collection</b><br/>
  We can inject collection values by constructor in spring framework. There <br/>
  can be used three elements inside the constructor-arg element.<br/>
  It can be:<br/>
    1-list<br/>
    2-set<br/>
    3-map<br/>
	<b class="redC">Example:-</b><br/>
	<pre>
	&lt;bean id="q" class="com.javatpoint.Question"&gt;   
	&lt;constructor-arg value="111"&gt;&lt;/constructor-arg&gt;   
	&lt;constructor-arg value="What is java?"&gt;&lt;/constructor-arg&gt;  
	&lt;constructor-arg&gt;   
	&lt;list&gt;   
	&lt;value&gt;Java is a programming language&lt;/value&gt;   
	&lt;value&gt;Java is a Platform&lt;/value&gt;   
	&lt;value&gt;Java is an Island of Indonasia&lt;/value&gt;   
	&lt;/list&gt;  
	&lt;/constructor-arg&gt;   
	&lt;/bean&gt;
	</pre>
	<b class="redC">Setter Injection :-</b><br/>
	<pre>
    &lt;bean id="obj" class="com.javatpoint.Employee"&gt;  
	&lt;property name="id"&gt;   
	&lt;value&gt;20&lt;/value&gt;    
	&lt;/property&gt;   
	&lt;property name="name"&gt;    
	&lt;value&gt;Arun&lt;/value&gt;   
	&lt;/property&gt;   
	&lt;property name="city"&gt;  
	&lt;value&gt;ghaziabad&lt;/value&gt;   
	&lt;/property&gt;   
	&lt;/bean&gt;  
	</pre>
	
	Setter Injection with Collection Example<br/>
	We can inject collection values by setter method in spring framework. There<br/>
	can be used three elements inside the property element.<br/>
	It can be:<br/>
    1-list<br/>
    2-set<br/>
    3-map<br/>
	<b class="redC">Example:-</b><br/>
	<pre>
	&lt;bean id="q" class="com.javatpoint.Question"&gt;   
	&lt;property name="id" value="1"&gt;&lt;/property&gt;   
	&lt;property name="name" value="What is Java?"&gt;&lt;/property&gt;   
	&lt;property name="answers"&gt;  
	&lt;list&gt;   
	&lt;value&gt;Java is a programming language&lt;/value&gt;   
	&lt;value&gt;Java is a platform&lt;/value&gt;   
	&lt;value&gt;Java is an Island&lt;/value&gt;  
	&lt;/list&gt;   
	&lt;/property&gt;  
	&lt;/bean&gt; 
	</pre>	
 </div>
   <div data-role="main" class="ui-content">
   
   <b class="redC">Dependency Injection with Factory Method in Spring :-</b><br/>
   To do so, we can use two attributes of bean element<br/>
   
   <b class="redC">1-factory-method:</b> represents the factory method that will be invoked to inject the bean.<br/>
   <b class="redC">2-factory-bean:</b> represents the reference of the bean by which factory method will be invoked.<br/>
   
   <b class="redC">It is used if factory method is non-static.</b> <br/>
   <b class="redC">Example:1-</b> 
   If class is like this<br/>
   <pre>  
   public class A {   
	private static final A obj=new A();  
	private A(){System.out.println("private constructor");}  
	public static A getA(){  
	    System.out.println("factory method ");  
	    return obj;  
	}  
	public void msg(){  
	    System.out.println("hello user");  
	}  
	}  
	</pre>
<b class="redC">Then dependency injection will be like :</b>
<pre>
&lt;bean id="a" class="com.javatpoint.A" factory-method="getA"&gt;&lt;/bean&gt;
</pre>
<b class="redC">Example:2-</b>
<pre>
	public class A {  
	    public void print() {  
	        System.out.println("hello a");  
	    }  
	  
	}  
public class PrintableFactory {  
	public static Printable getPrintable(){  <b class="redC">// It is static method</b>
	          return new A();
	}  
}
</pre>
<b class="redC">Then dependency injection will be :-</b><br/>
<pre>
&lt;bean id="p" class="com.javatpoint.PrintableFactory" factory-method="getPrintable"&gt;&lt;/bean&gt;
</pre>
<b class="redC">Example:3-</b><br/>
<pre>
public class PrintableFactory {  
<b class="redC">//non-static factory method</b> 
	public Printable getPrintable(){  
	    return new A();  
	}  
} 
</pre>
<b class="redC">Then dependency injection will be like this</b><br/> 
<pre>
&lt;bean id="pfactory" class="com.javatpoint.PrintableFactory"&gt;&lt;/bean&gt;  
&lt;bean id="p" class="com.javatpoint.PrintableFactory" factory-method="getPrintable" factory-bean="pfactory"&gt;&lt;/bean&gt;
</pre>  
</div>

  <div data-role="main" class="ui-content">
  <b class="redC">AOP:-</b><br/>
  A Concern is a term that refers to a part of the system divided on the basis of the functionality<br/>
    <b class="redC">Concerns are two types:-</b> <br/>
    The concerns representing single and specific functionality for primary requirements are known as core concerns.<br/>
    <b class="redC">or</b><br/>
    Primary functionlity of the system is knows as core concerns.<br/>
    <b class="redC">For example: Business logic</b><br/>
    The concerns representing functionalities for secondary requirements are referred to as 
	crosscutting concerns or system-wide concerns.<br/>
    <b class="redC">or</b><br/>
    The crosscutting concern is a concern which is applicable throughout the application and it affects the entire
	application.<br/>
    <b class="redC">For example:-</b>logging, security and data transfer are the concerns which are needed in almost every module of
	an application, hence they are cross-cutting concerns.<br/>
 </div>
 
  <div data-role="main" class="ui-content">
  <b class="redC">Why AOP :</b>-<br/>
  It provides the pluggable way to dynamically add the additional concern before, after or around the actual logic.<br/>
  <b class="redC">AOP Concepts and Terminology:-</b><br/>
  <b class="redC">Join point:-</b><br/>
  Join point is any point in your program such as method execution, exception handling, field access etc.
  Spring supports only method execution join point.<br/>
  <b class="redC">Advice:-</b><br/>
  Advice represents an action taken by an aspect at a particular join point. There are different types of advices<br/>
  Before Advice: it executes before a join point.<br/>
  After Returning Advice: it executes after a joint point completes normally.<br/>
  After Throwing Advice: it executes if method exits by throwing an exception.<br/>
  After (finally) Advice: it executes after a join point regardless of join point exit whether normally or exceptional return.<br/>
  Around Advice: It executes before and after a join point.<br/>
 <b class="redC">Pointcut:-</b> <br/>
 It is an expression language of AOP that matches join points.<br/>
 
 <b class="redC">Aspect:-</b><br/>
 It is a class that contains advices, joinpoints etc.<br/>
 
 <b class="redC">AOP Proxy:-</b><br/>
 It will be a JDK dynamic proxy or CGLIB proxy in spring framework.<br/>
 
 <b class="redC">Weaving:-</b><br/>
 It is the process of linking aspect with other application types.Weaving can be done at compile time, load time or runtime.<br/>
 Spring AOP performs weaving at runtime<br/>
 <b class="redC">Steps for AOP Implementations:-</b><br/>
 <b class="redC">Steps 1-</b>Adding dependencies<br/>
 <pre class="blueC">
 &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId &gt;
    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId &gt;
&lt;/dependency&gt;
 </pre>
 <b class="redC">Steps 2-</b>Enabling Spring AOP<br/>
 <pre class="blueC">
	@Configuration
	@EnableAspectJAutoProxy
	@ComponentScan
	public class AopConfig {
 
	}
 </pre>
 <b class="redC">Steps 3-</b>Define an Advice using Aspect and Pointcut Expression<br/>
 Each Aspect class should be annotated with @Aspect annotation. Within that class, we then specify Pointcuts and Advice.<br/>
 <pre class="blueC">
 @Aspect
 public class EmployeeCRUDAspect {
      
    @Before("execution(* EmployeeManager.getEmployeeById(..))")     //point-cut expression
    public void logBeforeV1(JoinPoint joinPoint) {

        System.out.println("EmployeeCRUDAspect.logBeforeV1() : " + joinPoint.getSignature().getName());
    }
 </pre>
 <b>Write methods on which you want to execute advice and those match with point-cut expressions.</b><br/>
 <pre class="blueC">
 @Component
public class EmployeeManager {

    public EmployeeDTO getEmployeeById(Integer employeeId) {
        System.out.println("Method getEmployeeById() called");
        return new EmployeeDTO();
    }
}
</pre>
  <b class="redC">Transaction management in Spring</b><br/>
  <b>Transaction managent using annotation:-</b><br/>
  <b>Step:1-</b>Make the below entry in xxxx-spring.xml file<br/>
  <pre>
  &lt;tx:annotation-driven proxy-target-class="true" transaction-manager="transactionManager" /&gt;
		
	&lt;bean id="transactionManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
		&lt;property name="dataSource" ref="dataSource" /&gt;
	&lt;/bean
  </pre>
  <b>Step:2-</b>Then we can use @Transaction directly <br/>
  <pre>
	@Transactional(rollbackFor=Exception.class)
		public class ServiceImp implements ServiceDao{
		
			@Autowired
			EmpDao emp;	
			
			@Override
			public int save(Emp p) {
				return emp.save(p);
			}
		
			@Override
			public int update(Emp p) {
				return emp.update(p);
			}
	}
	</pre>
	<b>Note:-</b><br/>
	You can also use <b>@EnableTransactionManagement</b> on configuration class to enable the @transaction instead of<br/>
	making entry in xxxx-servlet.xml file.<br/>
	<b class="redC">Transaction managent using only xml:-</b><br/>
	<pre>
		&lt;tx:advice id="txAdvice"  transaction-manager="transactionManager"&gt;
      	&lt;tx:attributes&gt;
       	&lt;tx:method name="<b class="redC">createEmployee</b>" rollback-for="Exception"&gt;&lt;/tx:method&gt;
      	&lt;/tx:attributes&gt;
  		&lt;/tx:advice&gt;
  		
  		&lt;aop:config proxy-target-class="true"&gt;
     	&lt;aop:pointcut   expression="execution(* com.javatpoint.EmpDAOImpl.createEmployee(..))" id="pid"&gt;&lt;/aop:pointcut&gt;
     	&lt;<b class="redC">aop:advisor advice-ref="txAdvice" pointcut-ref="pid</b>"&gt;&lt;/aop:advisor&gt;
   		&lt;/aop:config&gt;

		&lt;bean class="org.springframework.jdbc.datasource.DataSourceTransactionManager" id="transactionManager"&gt;
   	   	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; 
	</pre>
	<b class="redC">AOP using only xml:-</b><br/>
	<pre>
		&lt;bean id="track" class="com.javatpoint.TrackOperation"&gt;&lt;/bean&gt;
  		
  		&lt;aop:config&gt;
  		&lt;aop:aspect id="myAspect" ref="track"&gt;
     	&lt;aop:pointcut   expression="execution(* com.javatpoint.Student.study(..))" id="pointCutBefore"/&gt;
     	&lt;aop:before method="myadvice" pointcut-ref="pointCutBefore" /&gt;
     	&lt;/aop:aspect&gt;
   		&lt;/aop:config
	</pre>
	<b class="redC">Now TrackOperation class:-</b><br/>
	<pre>
	public class TrackOperation {
		 public void myadvice(JoinPoint jp)
		    {  
		        System.out.println("additional concern");  
		          
		    }  
		}
	</pre>
 </div>
 
 <div data-role="main" class="ui-content">
 <b class="redC">Type of view resolver in spring</b><br/>
 <b class="redC">1-</b>AbstractCachingViewResolver <br/>
 <b class="redC">2-</b>XmlViewResolver<br/>
 <b class="redC">3-</b>ResourceBundleViewResolver<br/>
 <b class="redC">4-</b>UrlBasedViewResolver <br/>
 <b class="redC">5-</b>InternalResourceViewResolver<br/>
 <b class="redC">6-</b>VelocityViewResolver/FreeMarkerViewResolver <br/>
 <b class="redC">7-</b>ContentNegotiatingViewResolver <br/>
 </div>
 
 <div data-role="main" class="ui-content">
<b class="redC">Problems of JDBC API</b><br/>
<br/>
The problems of JDBC API are as follows:<br/>
<br/>
    <b class="redC">1-</b>We need to write a lot of code before and after executing the query, such as creating connection,<br/>
	statement, closing resultset, connection etc.<br/>
    <b class="redC">2-</b>We need to perform exception handling code on the database logic.<br/>
    <b class="redC">3-</b>We need to handle transaction.<br/>
    <b class="redC">4-</b>Repetition of all these codes from one to another database logic is a time consuming task.<br/>
<br/>
<b class="redC">Spring Jdbc Approaches</b><br/>
	Spring framework provides following approaches for JDBC database access:<br/>
    <b class="redC">JdbcTemplate</b><br/>
    <b class="redC">NamedParameterJdbcTemplate</b><br/>
    <b class="redC">SimpleJdbcTemplate</b><br/>
    <b class="redC">SimpleJdbcInsert and SimpleJdbcCall</b><br/>
<br/>
JdbcTemplate :- This is the central class.<br/>
<br/>
Method which use in general :-<br/>
<br/>
1)public  int update(String query)	used for DML<br/>
2)public void execute(String query) used for DDL<br/>
3)public int[] batchUpdate (String query, List&lt;Object[]&gt; list);<br/>
4)public Map&lt;String, Object&gt; simpleJdbcProcCall (String procedure);<br/>
5)public Map&lt;String, Object&gt; jdbcProcedureInParam (String procedure, Object[] inParameters);<br/>
<br/>
<b class="redC">Question :-</b>what is controller?<br/>
<b class="redC">Answer :-</b> Is a class that handle HTTP request.<br/>
<b class="redC">Question:-</b>what is DispatcherServlet<br/>
<b class="redC">Answer :- </b>Is a central controller.<br/>
<b class="redC">Question:-</b>What are the scope of Spring beans.<br/>
<b class="redC">Answer</b>	:-1)Singleton 2)Prototype 3)request 4)session 5) global-session<br/>
 </div>
 
 <div data-role="main" class="ui-content">
 <b class="redC">Example :-</b><br/>
	<b class="redC">// Setter method based DI</b>
	<br/>
	<pre class="blueC">
	
   @Autowired
   public void setDepartment(Department department) {
      this.department = department;
   }
   <b class="redC">// Constructor based DI</b>
   @Autowired 
   public Company(Employee employee) { 
      this.employee = employee; 
   } 
   </pre>
 </div>
 
 <div data-role="main" class="ui-content">
 <b class="redC">What is use of BindingResult result</b><br/>
 <b class="redC">Answer:-</b>BindingResult use to check if there is any Binding Error<br/>
 <pre class="blueC">
 public String submit(@ModelAttribute("emp")Employee emp, BindingResult result, ModelMap model) {
        if (<b class="redC">result.hasErrors()</b>) {
            return "error";
        }
  </pre>      
  </div>
  
  <div data-role="main" class="ui-content">
  <b class="redC">What is @InitBinder and WebDataBinder in Spring MVC</b><br/>
  <b class="redC">Answer:-</b>If you want to customize the data binding inside a controller then we use 
      @InitBinder annotation on method and WebDataBinder as argument as below :<br/>
	  <font color="red">@InitBinder</font><br/>
	<pre class="blueC">
    public void bhusan(<font color="red">WebDataBinder binder</font>) {
        System.out.println("This is the InitBinder method of HomePageSubmitAction");
    	binder.setAllowedFields(new String[]{"name","contactNumber","id"});
	}
	</pre>
<b class="redC">CustomDateEditor:-</b><br/>	
CustomDateEditor is a property editor which is built in class in mvc 
like NumberEditor,BooleanEditor<br/> 
<font color="red">Question :-</font> Can we create our own property editor.<br/>
<font color="red">Answer :-</font> Yes we can create our own property editor ,Syntax as below<br/>

<pre class="blueC">
public class CustomEditorExample extends PropertyEditorSupport {
	@Override
	public void setAsText(String text) throws IllegalArgumentException {
		System.out.println("CustomEditorExample.java || This is a Custom editor Class");
	}
}
</pre>
<b class="redC">Question :-</b>How to  use form Validation in Spring MVC.<br/>
<b class="redC">Answer :-</b> We need to flow the below steps for form validation <br/>
<b class="redC">Step (1)</b> <br/>
		<pre class="blueC">
		public class Employee {
		@Size(min=18 , Max=40)
		private int age;
		private String name;
		}
		</pre>
 <b class="redC">Step(2)</b><br/>
		Changes inside controller<br/>
		
		<pre class="blueC">
		@RequestMapping(value = "/addEmployee", method = RequestMethod.POST)<br/>
        public String submit(@Valid @ModelAttribute("emp")Employee emp, BindingResult result, ModelMap model) {<br/>
		}<br/>
		</pre>
		
<b class="redC">Step(3)</b><br/>
 		And to use these annotation @size and  @Valid we need any third party validator<br/>
		library and in our project we are using Hibernate Validator Library.<br/>
  </div>
  
  <div data-role="main" class="ui-content">
  <b class="redC">@Configuration</b><br/>
  @Configuration annotation is part of the spring core framework. Spring 
  Configuration annotation indicates that the class has @Bean definition methods. 
  So Spring container can process the class and generate Spring Beans to be used 
  in the application.<br/>
  
  <b class="redC">@Autowired</b><br/>
  It is use to mark a dependency which Spring is going to resolve and inject. 
  We can use this annotation with a constructor, setter, or field injection.<br/>
  <b class="redC">Example</b><br/>
  
  <pre class="blueC">
     /*
	 <b class="redC">Field injection Auto-wire</b>
	 */
	@Autowired
	private Employee employee;
	
	/*
	 <b class="redC">Setter injection Auto-wire</b>
	 */
	@Autowired   
	public void setTreasureMap(TreasureMap treasureMap) {
		this.treasureMap = treasureMap;
	}
	/*
	 <b class="redC">Constructor injection Auto-wired</b>
	 */
	@Autowired
	public Pirate(Student student,<b class="redC">@Value</b>("chandra bhusan patel")String name) {
		super();
		this.student = student;
		this.name = name;
	}
	</pre>
   <b class="redC">@Value</b><br/>
	It is use for injecting property values into beans.  It’s compatible with constructor, setter, and field injection.<br/>
	<b class="redC">Example</b><br/>
	<pre>
	/*
	 * Use of @value on field
	 */
    <b class="redC">@Value</b>("Student_name")
	private String name;
	</pre>
	<b class="redC">@Order Annotation</b><br/>
	The @Order annotation defines the sorting order of an annotated component or bean. It has an optional value argument which determines the order of the component.<br/>
	<b class="redC">Type Autowiring Example</b><br/>
	If there is a interface <br/>
	<pre>
	<b class="redC">interface</b>
	public interface Formatter {
	
	public void format();

		}
		
	<b class="redC">and two classes implementing this interface</b>
	<b class="redC">Ist class</b>
	@Component
    public class BarFormatter implements Formatter {
	public void format() {
		System.out.println("This is the format method of BarFormatter");
	  }
	}
	<b class="redC">2nd class</b>
	@Component
	public class SimpleFormatter implements Formatter {

	public void format() {
		
		System.out.println("This is the format Method of SimpleFormatter");
	}
    }	
    <b class="redC">In configuration class we can inject the dependecy as below</b>
	</pre>	
	<b class="redC">Ist(This is autowiring by type)</b><br/>
	<pre>
	@Autowired
	private BarFormatter bar;
	
	@Autowired
	private SimpleFormatter sim;
	</pre>
	<b class="redC">2nd(This is autowiring by name)</b><br/>
	<pre>
	@Autowired
	private Formatter barFormatter;
	
	@Autowired
	private Formatter simpleFormatter;
	</pre>
	<b class="redC">3rd(Here we use @Qualifier because both by name and by type will not work)<br/>
	here neither name nor type matches because 'Formatter' is a interface.  
	</b><br/>
	<pre>
	@Autowired
	@Qualifier("barFormatter")
	private Formatter format;
	</pre>
  </div>
  <div data-role="main" class="ui-content">
  <b class="redC">How to use @Bean annotation</b><br/>
  If you use this is configuration class <br/>
  <pre>
  @Bean(name="studentBean") 
    public Student getBean() {
		System.out.println("ConfigurationClass.student");
    	return new Student();
	}
  </pre>
  Then you can get the bean like this<br/>
  Student student=(Student)context.getBean("studentBean");<br/>
  <b class="redC">Note:-If you do not give name to the bean then method name can be used as bean name</b><br/>
  <br/>
  <b class="redC">Use of @DependsOn annotation</b><br/>
  <b class="redC">Example :</b><br/>
  <pre>
    @Bean   
	@DependsOn("studentBean") <b class="redC">mean "studentBean" bean will initialize first then this bean.</b>
	public Employee getEmployee() {
		System.out.println("ConfigurationClass.getEmployee()");
		return new Employee();
	}
  </pre>
  <b class="redC">Example of @PropertySource </b><br/>
  <pre>
  @PropertySource("propertiesFile.properties") // Use of @PropertySource annotation 
  
  public class Pirate {
  
  @Autowired
	<b class="redC">@Value("${emp.name}") // Getting the value from properties resource</b> 
	public void setEmpName(String empName) {
		this.empName = empName;
	}
	
  }
  </pre>
  <b class="redC">Then in properties file</b><br/>
  emp.name=shashi bhusan patel <br/>
  <b class="redC">Example of @Import annotation</b><br/>
   Below is the use of Import Annotation
   if i will remove this annotation then I need to declare Student class as '@Component'
   means We can use specific @Configuration classes without component scanning with this annotation
  <pre>
	@Import(com.importExample.importResource.Student.class)
	public class MySingletonBean {
		@Autowired
		Student  student;
	}
  </pre>
  
  <b class="redC">Use of @ImportResource("classpath:bean.xml")</b><br/>
  <b class="redC">Example</b><br/>
  <pre>
  	@Configuration
  	@ImportResource("classpath:bean.xml")
	public class AppConfig {
	}
	<b class="redC">Then we can use like this :-</b>
    public static void main(String[] args) throws InterruptedException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        context.getBean(<b class="redC">"bean_id_mention_in_xml_file"</b>);
        }
  </pre>
  </div>
  <div data-role="main" class="ui-content">
  <b class="redC"> What is use of @Lazy Annotation</b><br/>
    We use @Lazy when we want to initialize our bean lazily. By default, 
	Spring creates all singleton beans eagerly at the startup/bootstrapping of the application context. 
	However, there are cases when we need to create a bean when we request it, not at application startup. 
	This annotation behaves differently depending on where we exactly place it. We can put it on:<br/>
	<br/>
    @Bean annotated bean factory method, to delay the method call (hence the bean creation)<br/>
    @Configuration class and all contained @Bean methods will be affected<br/>
    @Component class, which is not a @Configuration class, this bean will be initialized lazily<br/>
    @Autowired constructor, setter, or field, to load the dependency itself lazily (via proxy)<br/>
    <br/>
    <b class="redC">9)What is use of AOP in your project</b><br/>
    We are using this for maintaining the credit limit for sub-company,company or organization<br/>
    <b class="redC">Note:-</b><br/>
    What if we want to load a file called “bean.xml” instead of default “XXX-servlet.xml
    <pre>
    &lt;servlet&gt;
		&lt;servlet-name&gt;spring&lt;/servlet-name&gt;
		&lt;servlet-class&gt;
			org.springframework.web.servlet.DispatcherServlet
		&lt;/servlet-class&gt;
		&lt;init-param&gt;
			&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
		        &lt;param-value&gt;/WEB-INF/bean.xml&lt;/param-value&gt;
		&lt;/init-param&gt;
		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
	&lt;/servlet&gt;
	&lt;servlet-mapping&gt;
		&lt;servlet-name&gt;spring&lt;/servlet-name&gt;
		&lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
	&lt;/servlet-mapping
    </pre>
    <b class="redC">What is use of @Lookup </b><br/>
    A method annotated with @Lookup tells Spring to return an instance of the method’s return type when we invoke it.<br/>
    @Lookup is useful for:<br/>
    (1)-Injecting a prototype-scoped bean into a singleton bean.<br/>
    (2)-Injecting dependencies procedurally<br/>
    <b class="redC">Example :-</b><br/>
    <pre>
    <b class="redC">This is the prototype bean</b> 
    @Component
	@Scope("prototype")
	public class MyPrototypeBean {
	
	    private String dateTimeString = LocalDateTime.now().toString();
	
	    public String getDateTime() {
	        return dateTimeString;
	    }
	}
	<b class="redC">Now the singleton bean</b>
	@Component
		public class MySingletonBean {
			
		    public void showMessage(){
		    	<b class="redC">MyPrototypeBean bean=getPrototypeBean();</b>
		        System.out.println("Hi, the time is "+bean.getDateTime());
		    }
		 
		    <b class="redC">@Lookup</b>
		     public MyPrototypeBean getPrototypeBean(){
		     return  null;
		    }
		} 
	<b class="redC">Without @Lookup annotation</b>
	@Component
	public class MySingletonBean {
		@Autowired
		MyPrototypeBean bean;
		    public void showMessage(){
		    	//MyPrototypeBean bean=getPrototypeBean();
		        System.out.println("Hi, the time is "+bean.getDateTime());
		    }
		 
		   /* @Lookup
		     public MyPrototypeBean getPrototypeBean(){
		     return  null;
		    }*/
	}	
    </pre>
    <b class="redC">Limitation:-</b><br/>
    (1)-@Lookup-annotated methods won’t work at all when the surrounding class is @Bean-managed<br/>
    (2)-Method with @Lookup annotation cannot be private, static or final.<br/>
    <b class="redC">What is use of @Primary</b><br/>
    We can use @Primary to  mark the most frequently used bean with @Primary it will be chosen on unqualified injection points.<br/>
    <b class="redC">What is use of @Profile</b><br/>
    If we want Spring to use a @Component class or a @Bean method only when a specific profile is active, 
    we can mark it with @Profile. We can configure the name of the profile with the value argument of the annotation<br/>
    <pre>
    @Component
	@Profile("sportDay")
	class Bike implements Vehicle {}
	</pre>
	<b class="redC">@Required</b><br/>
	@Required on setter methods to mark dependencies that we want to populate through XML:<br/>
	<pre>
	@Required
	void setColor(String color) {
    this.color = color;
	}

	&lt;bean class="com.baeldung.annotations.Bike"&gt;
	&lt;property name="color" value="green" /&gt;
	&lt;/bean&gt;
	
	</pre>
	<b class="redC">Type of bean scope</b><br/>
	<b class="redC">1-</b>singleton<br/>
	<b class="redC">2-</b>prototype<br/>
	<b class="redC">3-</b>request<br/>
	<b class="redC">4-</b>session<br/>
	<b class="redC">5-</b>globalSession<br/>
	<b class="redC">6-</b>some custom scope<br/>
	<b class="redC">Example</b><br/>
	<pre>
	@Bean
	@Scope("singleton")
	public User getSingleton() {
		return new User();
	}

	@Bean
	@Scope("prototype")
	public User getPrototype() {
		return new User();
	}

	@Bean
	@Scope(value = WebApplicationContext.SCOPE_REQUEST)
	public User getRequest() {
		return new User();
	}

	@Bean
	@Scope(value = WebApplicationContext.SCOPE_SESSION)
	public User getSession() {
		return new User();
	}

	@Bean
	@Scope(value = WebApplicationContext.SCOPE_APPLICATION)
	public User getApplication() {
		return new User();
	}	
	</pre>
	<b class="redC">Important:-</b><br/>
	<pre>
	<b class="redC">@ImportResource("classpath:bean2.xml")</b>
	public class AppConfig {
    public static void main(String[] args) throws InterruptedException {
        @SuppressWarnings("resource")
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        Student student=(Student)context.getBean("student");
   	 }
	}
	<b class="redC">"student" is the bean Id in xml file</b>
	</pre>
	<b class="redC">Example of bean inheritance, used in case of XML configuration</b><br/>
	<pre>
		&lt;bean id="s1" class="inheriting.bean.Student"&gt;  
		&lt;constructor-arg value="Student Name"&gt;&lt;/constructor-arg&gt;
		&lt;constructor-arg value="Student Address"&gt;&lt;/constructor-arg&gt; 
		&lt;/bean&gt;
		
		 &lt;bean id="student" class="inheriting.bean.Student" <b class="redC">parent="s1"</b>&gt;  
		 &lt;constructor-arg&gt;
		 &lt;ref bean="j1"/&gt;
		 &lt;/constructor-arg&gt;
		&lt;/bean&gt;
	</pre>
	<b class="redC">Spring Expression language</b><br/>
	<pre>
    SpEL is an exression language supporting the features of querying and manipulating an object graph at runtime.
	It can be used with XML or annotation-based Spring.

	SpEL API

	The SpEL API provides many interfaces and classes. They are as follows:
	<b>
    Expression interface
    SpelExpression class
    ExpressionParser interface
    SpelExpressionParser class
    EvaluationContext interface
    StandardEvaluationContext class
    </b>
    <b class="redC">Note:-</b>
    
    <b class="redC">(1) AIRTHEMETIC OPERATOR:-</b>
    
    Divide and modulo operations have alphabetic aliases, div for / and mod for %. The + operator can also be used to concatenate strings.
    
    @Value("#{36 div 2}") // 18
	private double divideAlphabetic;
	
	@Value("#{37 mod 10}") // 7
	private double moduloAlphabetic;
	
	<b class="redC">(2) Relational and logical OPERATOR:-</b>
	
	All relational operators have alphabetic aliases, as well. For example, 
	in XML-based configs we can’t use operators containing angle brackets (&lt;, &lt;=, &gt;, &gt;=).
	Instead, we can use lt (less than), le (less than or equal), gt (greater than), or ge (greater than or equal). 
	
	@Value("#{1 &lt;= 1}") // true
	private boolean lessThanOrEqual;
	 
	@Value("#{1 le 1}") // true
	private boolean lessThanOrEqualAlphabetic;
	 
	@Value("#{1 > 1}") // false
	private boolean greaterThan;
	 
	@Value("#{1 gt 1}") // false
	private boolean greaterThanAlphabetic;
	 
	@Value("#{1 >= 1}") // true
	private boolean greaterThanOrEqual;
	 
	@Value("#{1 ge 1}") // true
	private boolean greaterThanOrEqualAlphabetic; 
	
	</pre>
	<b class="redC">More example of Spring Expression language</b><br/>
	<pre>
	<b class="redC">//This is how conditional operator will be used in SPEL</b>
	@Value("#{prototypeBean.name != null ? prototypeBean.name : 'default'}")
	private String name;
	
	private int age;
	<b class="redC">//This how we call a method using SPEL</b>
	@Value("#{prototypeBean.returnAddress()}")  
	private String address;
	</pre>
	<b class="redC">Bean life cycle using XML</b><br/>
	<b>Step-1-</b><br/>
	<pre>
	&lt;bean id="lifeBean" class="com.patel.lifecycle.LifeCycleBean" <b class="redC">init-method="start" destroy-method="stop"</b>&gt;&lt;/bean&gt;
	</pre>
	<b>Step-2-</b>Then two method in LifeCycleBean:-<br/>	
	<pre>
	public void start()
	{
		System.out.println("This is the life cycle bean start method");
	}
	public void stop()
	{
		System.out.println("This is the life cycle bean stop method");
	}
	</pre>
	<b class="redC">Bean life cycle using Annotation:-</b><br/>
	<b>Step:1-</b>Make that entry into xxx-servlet.xml file<br/>
	<pre>
	&lt;bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"/&gt;
	</pre>
	<b>Step:2-</b>Then we can use the below annotation <br/>
	<pre>
	@Component
	public class LifeCycleBean {
	
		public void display()
		{
			System.out.println("This is the LifeCycle display()");
		}
		
		<b class="redC">@PostConstruct</b>
		public void start()
		{
			System.out.println("This is the life cycle bean start method");
		}
		
		<b class="redC">@PreDestroy</b>
		public void stop()
		{
			System.out.println("This is the life cycle bean stop method");
		}

	}
	</pre>
	<b class="redC">Using InitializingBean,DisposableBean interface:-</b><br/>
	<pre>
	@Component
	public class BeanLifeCycle implements InitializingBean,DisposableBean{

		@Override
		public void <b class="redC">destroy()</b> throws Exception {
			System.out.println("BeanLifeCycle.java:destroy()");
		}
	
		@Override
		public void <b class="redC">afterPropertiesSet()</b> throws Exception {
			System.out.println("BeanLifeCycle.java:afterPropertiesSet()");
		}

	}
	</pre>
	<b class="redC">Question:-What is dependency injection DI:-</b><br/>
	Dependency Injection (DI) is a software design pattern that implements inversion of control for resolving dependencies.<br/>
	An injection is the passing of a dependency to a dependent object that would use it.<br/>
	<b class="redC">Spring MVC Execution Flow:-</b><br/>
	<img src="Spring_Flow.jpg" alt="Spring MVC Execution Flow"><br/>
	<b class="redC">Step 1:</b> First request will be received by DispatcherServlet.<br/>
	<b class="redC">Step 2:</b> DispatcherServlet will take the help of HandlerMapping and get to know the Controller class name associated with the given request.<br/>
	<b class="redC">Step 3:</b> So request transfer to the Controller, and then controller will process the request by executing appropriate methods and returns ModelAndView object (contains Model data and View name) back to the DispatcherServlet.<br/>
	<b class="redC">Step 4:</b> Now DispatcherServlet send the model object to the ViewResolver to get the actual view page.<br/>
	<b class="redC">Step 5:</b> Finally DispatcherServlet will pass the Model object to the View page to display the result.<br/>
  </div>
  <div data-role="main" class="ui-content">
  <b class="redC">Multiple view resolver strategies:-</b><br/>
  	If multiple view resolver strategies are applied, you have to declare the priority through “order” property<br/> 
  	where the lower order value has a higher priority<br/>
    <pre>
    &lt;beans ...&gt;
	&lt;bean class="org.springframework.web.servlet.view.XmlViewResolver"&gt;
	     &lt;property name="location"&gt;
	        &lt;value&gt;/WEB-INF/spring-views.xml&lt;/value&gt;
	     &lt;/property&gt;
	     &lt;<b class="redC">property name="order" value="0"</b> /&gt;
	&lt;/bean&gt;

	&lt;bean class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
	     &lt;property name="basename" value="spring-views" /&gt;
	     &lt;<b class="redC">property name="order" value="1"</b> /&gt;
	&lt;/bean&gt;
	
	&lt;bean id="viewResolver"
	      class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt;
              &lt;property name="prefix"&gt;
                 &lt;value&gt;/WEB-INF/pages/&lt;/value&gt;
              &lt;/property&gt;
              &lt;property name="suffix"&gt;
                 &lt;value&gt;.jsp&lt;/value&gt;
              &lt;/property&gt;
	      &lt;<b class="redC">property name="order" value="2"</b> /&gt;
        &lt;/bean&gt;
   &lt;/beans&gt;
    </pre>
  </div>
 
</div>
</body>
</html>
